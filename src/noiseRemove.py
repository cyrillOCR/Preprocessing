import time
import sys
import os

import imageio
import numpy
import cv2
from PIL import Image, ImageEnhance, ImageFilter

from threading import Thread

import imageio.core.util

"""Removes warnings generated by the librady imageio

"""

def silence_imageio_warning(*args, **kwargs):
    pass

imageio.core.util._precision_warn = silence_imageio_warning

"""Splits an image into two arrays for usage in thread processing
	:param image: image to perform split on
	:return first_half_array: the first half of the image as an array 
	:return second_half_array: the second half of the image as an array 
	:return width: the image width
	:return height: the image height

"""

def split_image(image):

    image = image.convert("L")

    image_array = get_array_from_image(image)
    width, height = image.size

    first_half_array = numpy.zeros((int(height / 2), width))

    for i in range(int(height / 2)):
        for j in range(width):
            first_half_array[i, j] = image_array[i, j]

    second_half_array = numpy.zeros((int(height / 2), width))

    for i in range(int(height / 2), height - 1):
        for j in range(width):
            second_half_array[int(height / 2) + 1 - i, j] = image_array[i, j]

    return first_half_array, second_half_array, width, height


"""Reconstruct an image as one array from two given arrays
	:param first_half_array: The first half of the array corresponding to the image to reconstruct
	:param second_half_array: The second half of the array corresponding to the image to reconstruct
	:param columns: The number of columns of the array
	:param rows: The number of rows of the array
	:return image_array: The array corresponding to the reconstructed image

"""

def reconstruct_image_as_array(first_half_array, second_half_array, columns, rows):

    image_array = numpy.zeros((rows, columns))

    for i in range(int(rows / 2)):
        for j in range(columns):
            image_array[i, j] = first_half_array[i, j]

    for i in range(int(rows / 2), rows):
        for j in range(columns):
            image_array[i, j] = second_half_array[int(rows / 2) + 1 - i, j]

    return image_array


"""Returns an image from a given array
	:param image_array: The array to be transformed to an image
	:return image: The corresponding image

"""

def get_image_from_array(image_array):

    image = Image.fromarray(image_array)
    return image

"""Returns an image from a given array
	:param image: The image from which the array will be get form
	:return image_array: The array from the corresponding image

"""

def get_array_from_image(image):

    image_array = numpy.asarray(image)
    return image_array

"""Saves an image given as an array to root location
	:param output_image_name: The name that will be given to the saved image
	:param image_array: The array coresponding to the image to be saved
"""

def save_image(output_image_name, image_array):

    imageio.imwrite(output_image_name, image_array)

"""Returns the opened image
	:param image_path: The name of the image to be opened
	:return : The opened image

"""

def open_image(image_path):
    return Image.open(image_path)


"""Applies the median filter to the given image as an array
	:param image: The image as an array to be applied the median filter
	:param result: An array to be saved the result of the median filter
	:param index: An index to specify the index of the array to contain the result from median filter

"""

def median_filter(image, result, index):

    width, height = image.size

    filtered_image = image.copy()

    members = [(0, 0)] * 9

    for x in range(1, width - 1, 4):
        for y in range(1, height - 1, 4):

            members[0] = image.getpixel((x - 1, y - 1))
            members[1] = image.getpixel((x - 1, y))
            members[2] = image.getpixel((x - 1, y + 1))
            members[3] = image.getpixel((x, y - 1))
            members[4] = image.getpixel((x, y))
            members[5] = image.getpixel((x, y + 1))
            members[6] = image.getpixel((x + 1, y - 1))
            members[7] = image.getpixel((x + 1, y))
            members[8] = image.getpixel((x + 1, y + 1))

            members.sort()

            filtered_image.putpixel((x, y), (members[4]))

    #filtered_image.show()
    result[index] = filtered_image

"""Uses median filter function with threads
	:param image: An image to process with median filter

"""

def median_filter_threads(image):

    threads = [None] * 2
    results = [None] * 2
    image_split = [None] * 2

    first_half_array, second_half_array, width, height = split_image(image)

    image_split[0] = get_image_from_array(first_half_array)
    image_split[1] = get_image_from_array(second_half_array)

    for i in range(0, len(threads)):
        threads[i] = Thread(target=median_filter, args=(image_split[i], results, i))
        threads[i].start()

    for i in range(0, len(threads)):
        threads[i].join()

    first_half_array = get_array_from_image(results[0])
    second_half_array = get_array_from_image(results[1])

    final_image_array = reconstruct_image_as_array(first_half_array, second_half_array, width, height)
    save_image("output_image_no_noise.jpg", final_image_array)

"""Removes a part of the pixels with high value from the image's histogram, using threads
	:param image: The image to process
	:param frequency: The percent of highest colored pixels to remove

"""

def remove_unwanted_pixels_threads(image, frequency=0.1):

    threads = [None] * 2
    results = [None] * 2
    image_split = [None] * 2

    first_half_array, second_half_array, width, height = split_image(image)

    image_split[0] = get_image_from_array(first_half_array)
    image_split[1] = get_image_from_array(second_half_array)

    for i in range(0, len(threads)):
        threads[i] = Thread(target=remove_unwanted_pixels, args=(image_split[i], results, i, frequency))
        threads[i].start()

    for i in range(0, len(threads)):
        threads[i].join()

    first_half_array = get_array_from_image(results[0])
    second_half_array = get_array_from_image(results[1])

    final_image_array = reconstruct_image_as_array(first_half_array, second_half_array, width, height)
    save_image("output_image_no_pixels.jpg", final_image_array)


"""Removes unwanted pixels from an image
	:param image_to_process: The image to be processed, given as an array
	:param result_object: An array to save the results from image processing
	:param index: An index to the array

"""


def remove_unwanted_pixels(image_to_process, result_object, thread_index, frequency=0.1):

    list_of_colors = image_to_process.getcolors()
    pixels = image_to_process.load()
    list_of_colors = sorted(list_of_colors, key=lambda x: x[0], reverse=True)
    selected_colors = [x[1] for x in list_of_colors[0:int(len(list_of_colors) * frequency)]]

    width, height = image_to_process.size

    for x in range(1, width):
        for y in range(1, height):
            if pixels[x, y] in selected_colors:
                pixels[x, y] = 255.0

    result_object[thread_index] = image_to_process

"""Transforms an image to only black and white pixels
	:param image_path: The path to the image to proccess
	:param level: The number of pixels to remain

"""

def posteriorizate(image_path, level):

    image_to_process = cv2.imread(image_path)
    color_list = numpy.arange(0, 256)
    divider = numpy.linspace(0, 255, level + 1)[1]
    quantization_colors = numpy.int0(numpy.linspace(0, 255, level)) 
    color_levels = numpy.clip(numpy.int0(color_list / divider), 0, level - 1)
    palette = quantization_colors[color_levels]
    processed_image = palette[image_to_process]
    processed_image = cv2.convertScaleAbs(processed_image)

    cv2.imwrite("output_image.jpg", processed_image)

"""Removes the created files from the processing functions

"""

def cleanup():
    if os.path.exists("output_image_levels.jpg"):
        os.remove("output_image_levels.jpg")
    if os.path.exists("output_image_no_noise.jpg"):
        os.remove("output_image_no_noise.jpg")
    if os.path.exists("output_image_no_pixels.jpg"):
        os.remove("output_image_no_pixels.jpg")

"""Calls the functions above on an image
	:param image: An image to process, given as Image

"""

def remove_noise(image):
    median_filter_threads(image)
    remove_unwanted_pixels_threads(open_image("output_image_no_noise.jpg"), 0.05)
    posteriorizate("output_image_no_pixels.jpg", 2)
    cleanup()
    return open_image("output_image.jpg")

"""Main function that calls the corresponding functions already discussed

"""


if __name__ == '__main__':

    # start_time = time.time()

    if len(sys.argv) != 2:
        print("Check your parameters! Usage: python <source.py> <image_path>")
    else:
        median_filter_threads(open_image(sys.argv[1]))
        remove_unwanted_pixels_threads(open_image("output_image_no_noise.jpg"), 0.05)
        posteriorizate("output_image_no_pixels.jpg", 2)
        cleanup()

    # print("Execution completed in %s seconds." % (time.time() - start_time))
